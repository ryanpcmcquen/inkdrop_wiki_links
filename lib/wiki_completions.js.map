{"version":3,"sources":["../src/wiki_completions.ts"],"names":["db","inkdrop","main","dataStore","getLocalDB","cursor","codeMirror","getCursor","gatherCandidates","term","note","utils","search","docs","length","map","doc","title","strategy","id","context","beforeCursor","match","index","callback","cache","replace","result","option","dropdown","className","maxCount","rotate","parent","document","body","item","activeClassName"],"mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA,MAAMA,EAAE,GAAGC,OAAO,iBAAIA,OAAJ,8DAAI,SAASC,IAAb,2EAAI,cAAeC,SAAnB,0DAAI,sBAA0BC,UAA1B,EAAJ,CAAlB,C,CAEA;AACA;;AACA,MAAMC,MAAM,GAAGJ,OAAO,kBAAIA,OAAJ,sEAAI,UAASK,UAAb,yDAAI,qBAAqBC,SAArB,EAAJ,CAAtB,C,CACA;AACA;AACA;AACA;;AAEO,MAAMC,gBAAgB,GAAG,MAAOC,IAAP,IAAgB;AAC5C,QAAMC,IAAI,GAAG,MAAMV,EAAE,CAACW,KAAH,CAASC,MAAT,CAAiB,SAAQH,IAAK,EAA9B,CAAnB;;AAEA,MAAIC,IAAI,SAAJ,IAAAA,IAAI,WAAJ,IAAAA,IAAI,CAAEG,IAAN,IAAcH,IAAI,CAACG,IAAL,CAAUC,MAAV,GAAmB,CAArC,EAAwC;AACpC,WAAOJ,IAAI,CAACG,IAAL,CAAUE,GAAV,CAAeC,GAAD,IAASA,GAAG,CAACC,KAA3B,CAAP;AACH,GAFD,MAEO;AACH,WAAO,CAAC,EAAD,CAAP;AACH;AACJ,CARM;;;AASA,MAAMC,QAAgB,GAAG;AAC5B;AACA;AACAC,EAAAA,EAAE,EAAE,SAHwB;AAI5B;AACA;AACA;AACAC,EAAAA,OAAO,EAAGC,YAAD,IAAmC;AACxC;AACA;;AACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGQ,WAAO,IAAP;AACH,GAxB2B;AAyB5B;AACA;AACA;AACA;AACA;AACA;AACA;AACAC,EAAAA,KAAK,EAAE,mBAhCqB;AAiC5B;AACA;AACAC,EAAAA,KAAK,EAAE,CAnCqB;AAoC5B;AACA;AACA;AACAX,EAAAA,MAAM,EAAE,OACJH,IADI,EAEJe,QAFI,EAGJF,KAHI,KAIY;AAChBE,IAAAA,QAAQ,CAAC,MAAMhB,gBAAgB,CAACC,IAAD,CAAvB,CAAR;AACH,GA7C2B;AA8C5B;AACAgB,EAAAA,KAAK,EAAE,KA/CqB;AAgD5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAC,EAAAA,OAAO,EAAGC,MAAD,IAA4B;AACjC,WAAQ,KAAIA,MAAO,IAAnB;AACH;AA5D2B,CAAzB;;AA8DA,MAAMC,MAAM,GAAG;AAClB;AACAC,EAAAA,QAAQ,EAAE;AACN;AACAC,IAAAA,SAAS,EAAE,qCAFL;AAGN;AACAC,IAAAA,QAAQ,EAAE,EAJJ;AAKN;AACA;AACA;AACA;AACA;AACA;AACA;AACAC,IAAAA,MAAM,EAAE,KAZF;AAaNC,IAAAA,MAAM,EAAEC,QAAQ,CAACC,IAbX;AAaiB;AACvB;AACA;AACA;AACA;AAEAC,IAAAA,IAAI,EAAE;AACF;AACAN,MAAAA,SAAS,EAAE,mBAFT;AAGF;AACAO,MAAAA,eAAe,EAAE;AAJf;AAnBA;AAFQ,CAAf","sourcesContent":["/*eslint no-debugger: false*/\n// This file is required by the index.html file and will\n// be executed in the renderer process for that window.\n// All of the Node.js APIs are available in this process.\n\nimport { CursorOffset, SearchResult } from \"@textcomplete/core\";\n\n// How to construct the editor object depends on the actual editor class.\n// Please read the document of the editor you choose.\n\n// When you finish using it.\n// This command also destroys the editor object.\n//textcomplete.destroy()\n\n// This is a sample strategy that autocompletes GitHub-style emoji notation.\n// This document page is using almost the same strategy for demo.\n//@ts-ignore\nconst db = inkdrop && inkdrop?.main?.dataStore?.getLocalDB();\n\n//the actual result of search\n//@ts-ignore\nconst cursor = inkdrop && inkdrop?.codeMirror?.getCursor();\n//experimental\n// const cmParentElement = document.querySelector(\n//     \"#app-container > div.main-layout.main-layout-slim > div.editor-layout > div.mde-layout > div > div.mde > div > div > div.CodeMirror-scroll > div.CodeMirror-sizer > div > div > div > div.CodeMirror-code\"\n// );\n\nexport const gatherCandidates = async (term) => {\n    const note = await db.utils.search(`title:${term}`);\n\n    if (note?.docs && note.docs.length > 0) {\n        return note.docs.map((doc) => doc.title);\n    } else {\n        return [\"\"];\n    }\n};\nexport const strategy: object = {\n    // (Optional) Identifier of the strategy. Will be appear on data-strategy\n    // attribute of a dropdown element.\n    id: \"mention\",\n    // (Optional) This function is called on every change before matching. The\n    // first argument is the string from head to cursor. If it returns `false`,\n    // following matching phase isn't started.\n    context: (beforeCursor: string): boolean => {\n        // Return false if the cursor is in code block or inline code notation\n        // to stop executing the matching phase.\n        /*\n        if (beforeCursor.indexOf(\"[\") > -1) {\n            const reversedCursor = beforeCursor.split(\"\").reverse();\n\n            if (\n                reversedCursor.indexOf(\"[\") < reversedCursor.indexOf(\"]\") ||\n                reversedCursor.indexOf(\"]\") < 0\n            ) {\n                return true;\n            }\n        }\n        */\n\n        return true;\n    },\n    // !isInClode(beforeCursor),\n    // (Required) On every change, the string from head to cursor tests with the\n    // RegExp. If it matches, the captured substring will be passed to the search\n    // parameter's first argument.\n    // See also \"index\" parameter.\n    // match: /\\B\\[\\[(.+?)/,\n    // match: /\\B\\[\\[([^\\]]+)/gm,\n    match: /\\[\\[([^\\]]+)(?=$)/,\n    // ///\\B:([\\-+\\w]*)$/,\n    // (Optional) Specify the index of target capture group. Default to 1.\n    index: 1,\n    // (Required) When the current input matches the \"match\" regexp above, this\n    // function is called. The first argument is the captured substring.\n    // You can callback only once for each search.\n    search: async (\n        term: string,\n        callback: (results: SearchResult<string>[]) => void,\n        match: RegExpMatchArray\n    ): Promise<void> => {\n        callback(await gatherCandidates(term));\n    },\n    // (Optional) Whether the search results are cached. Default false.\n    cache: false,\n    // (Optional) Specify how to render each search result on the dropdown UI.\n    // The argument is an element of the search results callbacked in the search\n    // phase.\n    //template: ([key, url]) =>\n    //`<img src=\"${url}\"/>&nbsp;<small>${key}</small>`,\n    // (Required) Specify how to update the editor value. The whole substring\n    // matched in the match phase will be replaced by the returned value.\n    // Note that it can return a string or an array of two strings. If it returns\n    // an array, the matched substring will be replaced by the concatenated string\n    // and the cursor will be set between first and second strings.\n    replace: (result: string): string => {\n        return `[[${result}]]`;\n    },\n};\nexport const option = {\n    // Configure a dropdown UI.\n    dropdown: {\n        // Class attribute of the dropdown element.\n        className: \"dropdown-menu textcomplete-dropdown\",\n        // The maximum number of items to be rendered.\n        maxCount: 10,\n        // Placement of the dropdown. \"auto\", \"top\" or \"bottom\".\n        //  placement: \"auto\",\n        // Return header and footer elements' content\n        //   header: (results) => \"\",\n        // footer: (results) => \"\",\n        // Whether activate the opposite side item on pressing up or\n        // down key when an edge item is active.\n        rotate: false,\n        parent: document.body, //.querySelector(\"#app-container > div.main-layout.main-layout-slim > div.editor-layout > div.mde-layout > div > div.mde > div > div > div.CodeMirror-scroll > div.CodeMirror-sizer > div > div > div > div.CodeMirror-code\"),\n        // Configure CSS style of the dropdown element.\n        // style: { display: \"none\", position: \"absolute\", zIndex: \"1000\" },\n        // The parent node of the dropdown element.\n        // parent: document.body,\n\n        item: {\n            // Class attribute of the each dropdown item element.\n            className: \"textcomplete-item\",\n            // Active item's class attribute.\n            activeClassName: \"textcomplete-item active\",\n        },\n    },\n};\n"],"file":"wiki_completions.js"}